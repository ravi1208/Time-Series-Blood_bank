for (i in x) {
print(x)
}
x
for (i in x) {
print(x)
++i
}
i++
}
for (i in x) {
print(x)
i
}
count = 0
while (count <10) {
print(count)
count ++
}
count = 0
while (count <10) {
print(count)
++count
}
count = 0
while (count <10) {
print(count)
count <- count +1
}
z = 5
z = 5
rbinom(1, 1, 0.5)
while(z >= 3 && z <= 10) {
coin <- rbinom(1, 1, 0.5)
if(coin == 1) {  ## random walk
z <- z + 1
} else {
z <- z - 1
}
}
print(z)
count = 0
while (count <10) {
print(count)
count <- count +1
}
for ( i in 1:count){
print(count)
}
for ( i in 1:count){
count <- count + 1
print(count)
}
count = 0
while (count <10) {
print(count)
count <- count +1
}
for ( i in 1:count){
count <- count + 1
print(count)
}
count = 1
for ( i in 1:count){
count <- count + 1
print(count)
}
count = 10
for ( i in 1:count){
count <- count + 1
print(count)
}
count = 10
for ( i in 1:count){
count <- count + 1
print(count)
}
count = 10
while (i <= count) {
print(count)
count <- count +1
}
count = 0
while (count <10) {
cat('This is loop number',count)
count <- count +1
print(count)
}
count = 10
for ( i in 1:count){
count <- count + 1
print(count)
}
count = 0
while (count <10) {
cat('This is loop number',count)
count <- count +1
print(count)
}
count = 0
for ( i in 1:count){
count <- count + 1
print(count)
}
count = 0
for ( i in 1:count){
count <- count + 1
cat('This is loop number',count)
print(count)
}
count = 0
for ( i in 1:count){
#count <- count + 1
cat('This is loop number',count)
print(count)
count <- count + 1
}
count = 0
for ( i in 1:count<10){
#count <- count + 1
cat('This is loop number',count)
print(count)
count <- count + 1
}
set.seed(123)
# Set variable stock and price
stock <- 50
price <- 50
# Loop variable counts the number of loops
loop <- 1
# Set the while statement
while (price > 45){
# Create a random price between 40 and 60
price <- stock + sample(-10:10, 1)
# Count the number of loop
loop = loop +1
# Print the number of loop
print(loop)
}
sample(-10:10, 1)
sample(1:10)
sample(1:10)
sample(1:10,1)
sample(1:10,2)
sample(1:10,2)
# Set the while statement
while (price > 45){
# Create a random price between 40 and 60
price <- stock + sample(-10:10, 1)
# Count the number of loop
loop = loop +1
cat('This is loop number',loop)
# Print the number of loop
print(loop)
}
set.seed(123)
# Set variable stock and price
stock <- 50
price <- 50
# Loop variable counts the number of loops
loop <- 1
# Set the while statement
while (price > 45){
# Create a random price between 40 and 60
price <- stock + sample(-10:10, 1)
# Count the number of loop
loop = loop +1
cat('This is loop number',loop)
# Print the number of loop
print(loop)
}
cat('it took',loop,'loop before we short the price. The lowest price is',price)
# Print 1 to 5
repeat{
cat('Prints 1 to 5')
print(x)
x = x + 1
if(x > 5){
break
}
}
# Print 1 to 5
repeat{
print(x)
x = x + 1
if(x > 5){
break
}
}
x = 1
# Print 1 to 5
repeat{
print(x)
x = x + 1
if(x > 5){
break
}
}
# Checks value is either positive, negative or zero
func <- function(x){
if(x > 0){
return("Positive")
}else if(x < 0){
return("Negative")
}else{
return("Zero")
}
}
func(1)
func(0)
func(-1)
is.prime <- function(num) {
if (num == 2) {
return(paste(num," is a prime number"))
} else if (any(num %% 2:(num-1) == 0)) {
return(paste(num," is not a prime number"))
} else {
return(paste(num," is a prime number"))
}
}
is.prime(55)
prime.ret(11)
prime.ret <- function(num) {
if (num == 2) {
return(paste(num," is a prime number"))
} else if (any(num %% 2:(num-1) == 0)) {
return(paste(num," is not a prime number"))
} else {
return(paste(num," is a prime number"))
}
}
prime.ret(11)
func(-1)
prime.ret(-1)
prime.ret(-12)
prime.ret(-7)
-5 %% 2
5 %%2
mod(3)
abs(4)
abs(-4)
as.integer(-1)
num = abs(as.integer(readline("Enter the number :")))
prime.ret <- function(num) {
if (num == 2) {
return(paste(num," is a prime number"))
} else if (any(num %% 2:(num-1) == 0)) {
return(paste(num," is not a prime number"))
} else {
return(paste(num," is a prime number"))
}
}
prime.ret(-7)
prime.ret(4)
prime.ret(5)
prime.ret(-5)
prime.ret <- function(num) {
if (abs(num) == 2) {
return(paste(num," is a prime number"))
} else if (any(abs(num) %% 2:(abs(num)-1) == 0)) {
return(paste(num," is not a prime number"))
} else {
return(paste(num," is a prime number"))
}
}
prime.ret(-5)
prime.ret <- function(num) {
if (num == 2) {
return(paste(num," is a prime number"))
} else if (any(num %% 2:(num-1) == 0)) {
return(paste(num," is not a prime number"))
} else {
return(paste(num," is a prime number"))
}
}
prime.ret(-5)
prime.ret <- function(num) {
if (num == 2) {
return(paste(num," is a prime number"))
} else if (any(num %% 2:(num-1) == 0)) {
return(paste(num," is not a prime number"))
} else {
return(paste(num," is a prime number"))
}
}
prime.ret(-5)
prime.ret.abs <- function(num) {
if (abs(num) == 2) {
return(paste(num," is a prime number"))
} else if (any(abs(num) %% 2:(abs(num)-1) == 0)) {
return(paste(num," is not a prime number"))
} else {
return(paste(num," is a prime number"))
}
}
prime.ret.abs(-5)
# Defining vector
nxt <- 1:10
# Print even numbers
for(i in nxt){
if(i%%2 != 0){
next #Jumps to next loop
}
print(i)
}
# Defining vector
nxt <- 1:20
# Print even numbers
for(i in nxt){
if(i%%2 != 0){
next #Jumps to next loop
}
print(i)
}
# Print even numbers
for(i in nxt){
if(i%%2 = 0){
next #Jumps to next loop
}
print(i)
}
# Defining vector
nxt <- 1:20
# Print even numbers
for(i in nxt){
if(i%%2 != 0){
next #Jumps to next loop
}
print(i)
}
# Print even numbers
for(i in nxt){
if(i%%2 == 0){
next #Jumps to next loop
}
print(i)
}
# Defining vector
nxt <- 1:20
# Print even numbers
for(i in nxt){
if(i%%2 != 0){
next #Jumps to next loop
}
print(i)
}
# Checks value is either positive, negative or zero
pos_neg <- function(x){
if(x > 0){
return("Positive")
}else if(x < 0){
return("Negative")
}else{
return("Zero")
}
}
pos_neg(1)
pos_neg(0)
pos_neg(-1)
setwd("D:/Self Appraisal/Time Series - BLood Bank")
getwd()
library(timeSeries)
library(openxlsx)
library(TTR)
library(tseries)
library(forecast)
require(XLConnectJars)
getwd()
wb <- loadWorkbook("Blood Bank Data Nashik Predicted.xlsx")
sheets(wb)
'Arpan Blood Bank Analysis'
collection <- readWorkbook(wb,sheet = "Collection Whole Blood Arpan")
Distribution <- readWorkbook(wb,sheet = "Distribution Arpan")
Distribution_total <- readWorkbook(wb,sheet = "Distribution Arpan Total Units")
#View(collection)
df_collect <- data.frame(collection[, c(-1,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14)])
#View(df_collect)
df1_collect <- df_collect[,c(-1,-2)]
#View(df1_collect)
test_data_collection <- ts(df1_collect,start=c(2010,8),end=c(2016,11),frequency = 12)
plot(test_data_collection)
#View(Distribution)
df_distribute <- data.frame(Distribution[, c(-1,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13)])
df1_distribute <- df_distribute[,c(-1,-2)]
View(df1_distribute)
test_data <- ts(df1_distribute,start=c(2013,1),end=c(2016,11),frequency = 12)
summary(test_data)
plot(test_data,main = "Distribution of Blood units for Jan 2013 - Nov-2016",
xlab="Time-Frame in Years", ylab="Units of Blood samples issued",
type = "l")
#View(Distribution_total)
df_distribute_total <- data.frame(Distribution_total[, c(-1,-4,-5)])
#View(df_distribute_total)
typeof(df_distribute_total)
df1_distribute_total <- as.integer( df_distribute_total[,c(-1,-2)])
test_data_distribute_total <- ts(df1_distribute_total,start=c(2013,1),end=c(2016,11),frequency = 12)
plot(test_data_distribute_total,main = "Distribution of Blood units for Jan 2013 - Nov-2016",
xlab="Time-Frame in Years", ylab="Units of Blood samples issued",
type = "l" )
#blood GRoupwise
#View(Distribution)
df_distribute_BG <- data.frame(Distribution[, c(-1,-4,-5,-7,-8,-9,-10,-11,-12,-13,-14)])
#View(df_distribute_BG)
df1_distribute_BG <- (df_distribute_BG[,c(-1,-2)])
test_data_distribute_BG <- ts(df1_distribute_BG,start=c(2013,1),end=c(2016,11),frequency = 12)
plot(test_data_distribute_BG,main = "Distribution of Blood units for Jan 2013 - Nov-2016",
xlab="Time-Frame in Years", ylab="Units of Blood samples issued",
type = "h" )
accuracy(meanf(test_data_distribute_BG,h=5,fan = F,lambda = NULL))
accuracy(naive(test_data_distribute_BG,h=5,fan = F,lambda = NULL))
accuracy(rwf(test_data_distribute_BG,h=5,fan = F,lambda = NULL))
?accuracy
beer2 <- window(ausbeer,start=1992,end=c(2007,4))
getwd()
ausbeer <- read.csv("beer.csv")
beer2 <- window(ausbeer,start=1992,end=c(2007,4))
beer2 <- window(ausbeer$OzBeer,start=1992,end=c(2007,4))
ausbeer <- read.csv("beer.csv",header = F)
beer2 <- window(ausbeer$OzBeer,start=1992,end=c(2007,4))
accuracy(meanf(test_data_distribute_BG,h=5,fan = F,lambda = NULL))
accuracy(naive(test_data_distribute_BG,h=5,fan = F,lambda = NULL))
accuracy(rwf(test_data_distribute_BG,h=5,fan = F,lambda = NULL))
?tsCV
e <- tsCV(test_data_distribute_BG, mean, h=1,window =1)
e <- tsCV(test_data_distribute_BG, rwf, drift=TRUE, h=1,window = 30)
print(e)
e <- tsCV(test_data_distribute_BG, mean, drift=TRUE, h=1,window = 30)
e <- tsCV(test_data_distribute_BG, naive, drift=TRUE, h=1,window = 30)
print(e)
e <- tsCV(test_data_distribute_BG, rwf, drift=TRUE, h=1,window = 30)
print(e)
plot(e)
#print(e)
#plot(e)
'RMSE'
sqrt(mean(e^2, na.rm=TRUE))
'Residual RMSE'
sqrt(mean(residuals(rwf(test_data_distribute_BG, drift=TRUE))^2, na.rm=TRUE))
#ADF TEST
adf.test(test_data_distribute_total,alternative = "stationary")
#Differencing the data
diff_data <- diff(test_data_distribute)
#blood GRoupwise
#View(Distribution)
df_distribute_BG <- data.frame(Distribution[, c(-1,-4,-5,-7,-8,-9,-10,-11,-12,-13,-14)])
#View(df_distribute_BG)
df1_distribute_BG <- (df_distribute_BG[,c(-1,-2)])
#write.csv(df1_distribute_BG, file = "Mydata.csv",row.names = T,)
test_data_distribute_BG <- ts(df1_distribute_BG,start=c(2013,1),end=c(2016,11),frequency = 12)
plot(test_data_distribute_BG,main = "Distribution of Blood units for Jan 2013 - Nov-2016",
xlab="Time-Frame in Years", ylab="Units of Blood samples issued",
type = "h" )
#ADF TEST
adf.test(test_data_distribute_BG,alternative = "stationary")
#Kwiatkowski-Phillips-Schmidt-Shin (KPSS) test. This reverses the hypotheses,
#so the null-hypothesis is that the data are stationary. In this case,
#small p-values (e.g., less than 0.05) suggest that differencing is required.
#reverse of adftest
kpss.test(test_data_distribute_BG)
#Differencing the data
diff_data <- diff(test_data_distribute_BG)
diff_data
?stl
#check for seasonality in data
Stl = stl(x =test_data_distribute_BG,s.window = "periodic")
summary(Stl)
auto.arima(test_data_distribute_BG)
fit <- Arima(test_data_distribute_BG)
fit
plot(forecast(fit,h=3),main = "Forecast for Next three months",
xlab="Time-Frame in Years", ylab="Units of Blood samples issued",
type = "h")
plot(forecast(fit,h=3),main = "Forecast for Next three months",
xlab="Time-Frame in Years", ylab="Units of Blood samples issued",
type = "l")
Box.test(test_data,lag=1,type="Ljung")
plot(pacf(test_data_distribute_total,lag.max = NULL,na.action = na.pass,plot = F),
main = "Partial ACF ")
plot(pacf(test_data_distribute_BG,lag.max = NULL,na.action = na.pass,plot = F),
main = "Partial ACF ")
plot(acf(test_data_distribute_BG,lag.max = NULL,na.action = na.pass,
plot = F,type = "correlation"),main = "ACF")
acf(fit$residuals)
forecast(auto.arima(test_data_distribute_BG))
#n.ahead species the number of years the prediction is required.
predicted  <- predict(fit, n.ahead =2 )
plot(predicted$pred)
predicted
#prediction in the month of January till 2015
plot <- ts.plot(test_data_distribute_total,2.718^predicted$pred, log = "y", lty = c(1,3),
xlab="Time-Frame in Years", ylab="Units of Blood samples issued",
main = "Prediction for January month till 2025",type ="h")
#smoothening the plot
test_smooth <- HoltWinters(test_data_distribute_total,beta = F,gamma = F)
plot(test_smooth)
(test_smooth$seasonal)
plot(test_smooth$fitted)
plot(HoltWinters(test_data,beta = F,gamma = F,
#                seasonal = "additive",l.start = 618.4467))
forecast_data <- forecast.HoltWinters(test_smooth,h=5)
#plot.forecast(forecast_data,type = "l")
acf(forecast_data$residuals,lag.max = 20,na.action = na.pass)
plot(HoltWinters(test_data,beta = F,gamma = F,
seasonal = "additive",l.start = 618.4467))
forecast_data <- forecast.HoltWinters(test_smooth,h=5)
plot.forecast(forecast_data,type = "l")
#plot.forecast(forecast_data,type = "l")
acf(forecast_data$residuals,lag.max = 20,na.action = na.pass)
forecast_data <- forecast.HoltWinters(test_smooth,h=5)
plot(forecast(fit,h=3),main = "Forecast for Next three months",
xlab="Time-Frame in Years", ylab="Units of Blood samples issued",
type = "l")
